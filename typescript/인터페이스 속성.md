# 인터페이스 속성
타입스크립트는 인터페이스 속성을 모델링할 때 유용한 타입 시스템 도구를 제공한다.

## 선택적 속성
모든 객체가 필수적으로 인터페이스 속성을 가질 필요는 없다.  
타입 애너테이션 앞에 **?** 를 사용해 인터페이스의 속성이 선택적 속성임을 나타낼 수 있다.
```typescript
interface Book {
    author?: string;
    pages: number;
}

const ok: Book = {
    author: "Rita Dove",
    pages: 80,
};

const missing: Book = {
    pages: 80
};
```

## 읽기 전용 속성
경우에 따라 인터페이스에 정의된 객체의 속성을 재할당하지 못하도록 인터페이스 사용자를 차단할 수 있다.  
속성 이름 앞에 **readonly** 키워드를 추가하면 다른 값으로 설정할 수 없음을 나타낸다.
```typescript
interface Page {
    readonly text: string;
}

function read(page: Page) {
    // Ok: text 속성을 수정하지 않고 읽는 것
    console.log(page.text);

    page.text += "!";
    //   ~~~~
    // Error: Cannot assign to 'text' because it is a read-only property.
}
```
readonly 제한자는 타입 시스템에만 존재하며 인터페이스에서만 사용할 수 있다.  
readonly 제한자는 인터페이스를 선언하는 위치에서만 사용되고 실제 객체에는 적용되지 않는다.  

위 코드 스니펫에서는 함수 밖에서 속성을 수정할 수 있다.  
쓰기 가능한 가변 속성은 readonly 속성이 필요한 모든 위치에서 읽을 수 있다.  
```typescript
interface Page {
    readonly text: string;
}

function read(page: Page) {
    console.log(page.text);
}

const pageIsh = {
    text: "Hello, world!",
};

// Ok: pageIsh는 Page 객체가 아니라 text가 있는, 유추된 객체 타입이다.
pageIsh.text += "!";

// pageIsh의 더 구체적인 버전인 Page를 읽는다.
read(pageIsh);
```

선언된 PageIsh의 text 속성은 유추된 타입이였기 때문에 readonly가 아니었다.  

readonly 인터페이스 멤버는 코드 영역에서 객체를 의도치 않게 수정하는 것을 막는 편리한 방법이다.  
readonly는 타입 시스템 구성 요소일 뿐 컴파일된 자바스크립트 코드에는 존재하지 않음.  
단지 타입 검사기를 사용해 개발 중에 그 속성이 수정되지 못하도록 보호하는 역할이다.  

## 함수와 메서드
자바스크립트에서 객체 멤버가 함수가 되는 것은 일반적이다.  
타입스크립트에서도 인터페이스 멤버를 함수 타입으로 선언할 수 있다.  
타입스크립트는 인터페이스 멤버를 함수로 선언하는 두 가지 방법이 있다.
- **메서드 구문**: 인터페이스 멤버를 meber(): void와 같이 객체의 멤버로 호출되는 함수로 선언
- **속성 구문**: 인터페이스의 멤버를 member: () => void와 같이 독립 함수처럼 선언

```typescript
interface HasBothFunctionTypes {
    property: () => string;
    method(): string;
}

const hasBoth: HasBothFunctionTypes = {
    property: () => "",
    method() {
        return "";
    }
};

hasBoth.property(); // Ok
hasBoth.method(); // Ok
```

두 가지 방법 모두 선택적 속성 키워드인 **?** 를 사용할 수 있다.
```typescript
interface HasBothFunctionTypes {
    optionnalProperty?: () => string;
    optionalMethod?(): string;
}
```

메서드 구문과 속성 구문은 몇 가지 차이점이 존재한다.
- 메서드는 readonly로 선언할 수 없지만 속성은 가능하다.
- 인터페이스 병합은 메서드와 속성을 다르게 처리한다.
- 타입에서 수행되는 일부 작업은 메서드와 속성을 다르게 처리한다.

현시점에서 추천하는 스타일 가이드는 다음과 같다.  
- 기본 함수가 **this**를 참조할 수 있다면 메서드를 사용(ex. 클래스의 인스턴스)
- 반대의 경우는 속성 함수를 사용